/*
Premium Ultra Smart Qur'onIQ
Logic Architecture
© Muhammad Daler
*/

// ============================================================
// CORE CONTROLLER - State Management & Test Lifecycle
// ============================================================

class CoreController {
    constructor() {
        this.state = 'idle'; // idle | running | finished
        this.testSession = null;
        this.currentQuestionIndex = 0;
        this.responses = [];
        this.startTimestamp = null;
        this.endTimestamp = null;
        this.observers = [];
    }

    subscribe(callback) {
        this.observers.push(callback);
    }

    notify(eventType, data) {
        this.observers.forEach(cb => cb({ type: eventType, data }));
    }

    startTest(testConfig) {
        if (this.state !== 'idle') {
            throw new Error('Test already in progress');
        }

        this.testSession = {
            testId: Math.random().toString(36).substr(2, 9),
            config: testConfig,
            createdAt: new Date().toISOString(),
        };

        this.currentQuestionIndex = 0;
        this.responses = [];
        this.startTimestamp = Date.now();
        this.state = 'running';

        this.notify('test:started', { testId: this.testSession.testId });
        return this.testSession;
    }

    submitAnswer(questionId, selectedOptionIndex, timeSpentMs) {
        if (this.state !== 'running') {
            throw new Error('No test in progress');
        }

        this.responses.push({
            questionId,
            selectedOptionIndex,
            timeSpentMs,
            timestamp: Date.now(),
        });

        this.currentQuestionIndex++;
        this.notify('answer:submitted', { questionIndex: this.currentQuestionIndex });
    }

    finishTest() {
        if (this.state !== 'running') {
            throw new Error('No test in progress');
        }

        this.endTimestamp = Date.now();
        const totalTimeMs = this.endTimestamp - this.startTimestamp;

        const result = {
            testId: this.testSession.testId,
            config: this.testSession.config,
            responses: this.responses,
            totalTimeMs,
            createdAt: this.testSession.createdAt,
            completedAt: new Date().toISOString(),
        };

        this.state = 'finished';
        this.notify('test:finished', result);

        return result;
    }

    resetTest() {
        this.state = 'idle';
        this.testSession = null;
        this.currentQuestionIndex = 0;
        this.responses = [];
        this.startTimestamp = null;
        this.endTimestamp = null;
        this.notify('test:reset', {});
    }

    getState() {
        return {
            state: this.state,
            currentQuestionIndex: this.currentQuestionIndex,
            totalResponses: this.responses.length,
            testId: this.testSession?.testId,
        };
    }
}

// ============================================================
// TEST ENGINE - Question Generation & Management
// ============================================================

class TestEngine {
    constructor() {
        this.questionPool = this.buildQuestionPool();
        this.usedQuestions = new Set();
    }

    buildQuestionPool() {
        const surahs = [
            { id: 1, name: 'Al-Fatiha', ayahs: 7, category: 'tajwid' },
            { id: 2, name: 'Al-Baqarah', ayahs: 286, category: 'hifz' },
            { id: 3, name: 'Ali Imran', ayahs: 200, category: 'tafsir' },
            { id: 4, name: 'An-Nisa', ayahs: 176, category: 'hifz' },
            { id: 5, name: 'Al-Maaidah', ayahs: 120, category: 'tajwid' },
            { id: 6, name: 'Al-Anam', ayahs: 165, category: 'hifz' },
            { id: 7, name: 'Al-Araf', ayahs: 206, category: 'tafsir' },
            { id: 8, name: 'Al-Anfal', ayahs: 75, category: 'hifz' },
            { id: 9, name: 'At-Tawbah', ayahs: 129, category: 'tafsir' },
            { id: 10, name: 'Yunus', ayahs: 109, category: 'tajwid' },
            { id: 11, name: 'Hud', ayahs: 123, category: 'hifz' },
            { id: 12, name: 'Yusuf', ayahs: 111, category: 'hifz' },
            { id: 13, name: 'Ar-Ra\'ad', ayahs: 43, category: 'tajwid' },
            { id: 14, name: 'Ibrahim', ayahs: 52, category: 'tafsir' },
            { id: 15, name: 'Al-Hijr', ayahs: 99, category: 'hifz' },
            { id: 16, name: 'An-Nahl', ayahs: 128, category: 'tafsir' },
            { id: 17, name: 'Al-Isra', ayahs: 111, category: 'hifz' },
            { id: 18, name: 'Al-Kahf', ayahs: 110, category: 'hifz' },
            { id: 19, name: 'Maryam', ayahs: 98, category: 'tafsir' },
            { id: 20, name: 'Taha', ayahs: 135, category: 'tajwid' },
            { id: 21, name: 'Al-Anbiya', ayahs: 112, category: 'hifz' },
            { id: 22, name: 'Al-Hajj', ayahs: 78, category: 'tafsir' },
            { id: 23, name: 'Al-Mu\'minun', ayahs: 118, category: 'hifz' },
            { id: 24, name: 'An-Nur', ayahs: 64, category: 'tajwid' },
            { id: 25, name: 'Al-Furqan', ayahs: 77, category: 'tafsir' },
            { id: 26, name: 'Ash-Shu\'ara', ayahs: 227, category: 'hifz' },
            { id: 27, name: 'An-Naml', ayahs: 93, category: 'tafsir' },
            { id: 28, name: 'Al-Qasas', ayahs: 88, category: 'hifz' },
            { id: 29, name: 'Al-Ankabut', ayahs: 69, category: 'tajwid' },
            { id: 30, name: 'Ar-Rum', ayahs: 60, category: 'tafsir' },
        ];

        const pool = [];
        surahs.forEach(surah => {
            for (let ayahNum = 1; ayahNum <= Math.min(surah.ayahs, 10); ayahNum++) {
                pool.push({
                    questionId: `q_${surah.id}_${ayahNum}`,
                    surahId: surah.id,
                    surahName: surah.name,
                    ayahNumber: ayahNum,
                    category: surah.category,
                    type: 'continuation', // or 'identification', 'meaning'
                    difficulty: this.calculateDifficulty(surah.id, ayahNum),
                });
            }
        });

        return pool;
    }

    calculateDifficulty(surahId, ayahNum) {
        const baseDifficulty = surahId <= 10 ? 1 : surahId <= 20 ? 2 : 3;
        const ayahDifficulty = ayahNum <= 5 ? 0 : ayahNum <= 10 ? 1 : 2;
        return Math.min(5, baseDifficulty + ayahDifficulty);
    }

    generateQuestions(count, testConfig) {
        const { category, difficulty, surahId } = testConfig;

        let availableQuestions = this.questionPool.filter(q => {
            let matches = true;
            if (category && q.category !== category) matches = false;
            if (difficulty && q.difficulty !== difficulty) matches = false;
            if (surahId && q.surahId !== surahId) matches = false;
            if (this.usedQuestions.has(q.questionId)) matches = false;
            return matches;
        });

        if (availableQuestions.length < count) {
            this.usedQuestions.clear();
            availableQuestions = this.questionPool.filter(q => {
                let matches = true;
                if (category && q.category !== category) matches = false;
                if (difficulty && q.difficulty !== difficulty) matches = false;
                if (surahId && q.surahId !== surahId) matches = false;
                return matches;
            });
        }

        const questions = [];
        for (let i = 0; i < Math.min(count, availableQuestions.length); i++) {
            const randomIndex = Math.floor(Math.random() * availableQuestions.length);
            const question = availableQuestions[randomIndex];
            questions.push(question);
            this.usedQuestions.add(question.questionId);
            availableQuestions.splice(randomIndex, 1);
        }

        return questions.map(q => ({
            ...q,
            options: this.generateOptions(q),
            correctOptionIndex: 0,
        }));
    }

    generateOptions(question) {
        return ['A', 'B', 'C', 'D'];
    }

    markQuestionUsed(questionId) {
        this.usedQuestions.add(questionId);
    }

    clearUsedQuestions() {
        this.usedQuestions.clear();
    }
}

// ============================================================
// IQ SCORING ENGINE - Advanced Psychometric Calculation
// ============================================================

class IQScoringEngine {
    static IQ_MIN = 50;
    static IQ_MAX = 160;
    static IQ_MEAN = 100;
    static IQ_STDDEV = 15;

    static calculateIQ(testResult, userHistory) {
        const accuracy = this.calculateAccuracy(testResult);
        const speedFactor = this.calculateSpeedFactor(testResult);
        const difficultyFactor = this.calculateDifficultyFactor(testResult);
        const consistencyFactor = this.calculateConsistency(testResult, userHistory);
        const reasoningDepth = this.calculateReasoningDepth(testResult);

        const weights = {
            accuracy: 0.40,
            speed: 0.20,
            difficulty: 0.15,
            consistency: 0.15,
            reasoning: 0.10,
        };

        const compositeScore =
            accuracy * weights.accuracy +
            speedFactor * weights.speed +
            difficultyFactor * weights.difficulty +
            consistencyFactor * weights.consistency +
            reasoningDepth * weights.reasoning;

        let iqScore = this.IQ_MEAN + compositeScore * this.IQ_STDDEV;
        iqScore = Math.max(this.IQ_MIN, Math.min(this.IQ_MAX, Math.round(iqScore)));

        return {
            iq: iqScore,
            components: {
                accuracy: (accuracy * 100).toFixed(1),
                speed: (speedFactor * 100).toFixed(1),
                difficulty: (difficultyFactor * 100).toFixed(1),
                consistency: (consistencyFactor * 100).toFixed(1),
                reasoning: (reasoningDepth * 100).toFixed(1),
            },
            level: this.getLevel(iqScore),
        };
    }

    static calculateAccuracy(testResult) {
        const { responses, questions } = testResult;
        const correct = responses.filter((resp, idx) => 
            resp.selectedOptionIndex === questions[idx].correctOptionIndex
        ).length;
        return Math.min(1, correct / responses.length);
    }

    static calculateSpeedFactor(testResult) {
        const avgTimeMs = testResult.totalTimeMs / testResult.responses.length;
        const normalizedTime = Math.min(avgTimeMs / 30000, 1); // 30 sec per question baseline
        return 1 - (normalizedTime * 0.3); // Speed accounts for 30% variance
    }

    static calculateDifficultyFactor(testResult) {
        const avgDifficulty = testResult.questions.reduce((sum, q) => sum + q.difficulty, 0) / testResult.questions.length;
        return Math.min(1, avgDifficulty / 5); // Normalized to 0-1
    }

    static calculateConsistency(testResult, userHistory) {
        if (!userHistory || userHistory.length < 2) return 0.5;

        const recentScores = userHistory.slice(-5).map(h => h.accuracy);
        const variance = this.variance(recentScores);
        const consistency = Math.max(0, 1 - variance);

        return Math.min(1, consistency);
    }

    static calculateReasoningDepth(testResult) {
        const categoryCounts = {};
        testResult.questions.forEach(q => {
            categoryCounts[q.category] = (categoryCounts[q.category] || 0) + 1;
        });

        const uniqueCategories = Object.keys(categoryCounts).length;
        return Math.min(1, uniqueCategories / 3); // Max 3 categories
    }

    static variance(arr) {
        const mean = arr.reduce((a, b) => a + b) / arr.length;
        const squareDiffs = arr.map(value => Math.pow(value - mean, 2));
        return squareDiffs.reduce((a, b) => a + b) / arr.length;
    }

    static getLevel(iq) {
        if (iq >= 145) return { name: 'Genius', code: 'genius', rank: 1 };
        if (iq >= 130) return { name: 'Very Superior', code: 'very_superior', rank: 2 };
        if (iq >= 115) return { name: 'Superior', code: 'superior', rank: 3 };
        if (iq >= 100) return { name: 'Average', code: 'average', rank: 4 };
        if (iq >= 85) return { name: 'Below Average', code: 'below_average', rank: 5 };
        return { name: 'Significantly Below Average', code: 'significantly_below', rank: 6 };
    }

    static percentileRank(iq) {
        // Using normal distribution approximation
        const z = (iq - this.IQ_MEAN) / this.IQ_STDDEV;
        return this.normalCDF(z) * 100;
    }

    static normalCDF(z) {
        return (1 + Math.erf(z / Math.sqrt(2))) / 2;
    }

    static erf(x) {
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;

        const sign = x < 0 ? -1 : 1;
        x = Math.abs(x);

        const t = 1 / (1 + p * x);
        const t2 = t * t;
        const t3 = t2 * t;
        const t4 = t3 * t;
        const t5 = t4 * t;

        return sign * (1 - (((((a5 * t5 + a4 * t4) + a3 * t3) + a2 * t2) + a1 * t) * Math.exp(-x * x)));
    }
}

// ============================================================
// SMART ADAPTIVE ENGINE - Intelligent Difficulty & Learning
// ============================================================

class SmartAdaptiveEngine {
    constructor(userHistory = []) {
        this.userHistory = userHistory;
        this.performanceTrend = this.calculateTrend();
    }

    calculateTrend() {
        if (this.userHistory.length < 2) return 'stable';

        const recentResults = this.userHistory.slice(-5);
        const scores = recentResults.map(r => r.iq);

        let trending = 0;
        for (let i = 1; i < scores.length; i++) {
            trending += scores[i] - scores[i - 1];
        }

        const avgTrend = trending / (scores.length - 1);

        if (avgTrend > 5) return 'improving';
        if (avgTrend < -5) return 'declining';
        return 'stable';
    }

    recommendNextDifficulty() {
        if (this.userHistory.length === 0) return 'medium';

        const lastResult = this.userHistory[this.userHistory.length - 1];
        const accuracy = parseFloat(lastResult.components.accuracy);

        if (this.performanceTrend === 'improving') {
            if (accuracy > 80) return 'hard';
            if (accuracy > 65) return 'medium';
            return 'easy';
        }

        if (this.performanceTrend === 'declining') {
            if (accuracy < 50) return 'easy';
            if (accuracy < 65) return 'medium';
            return 'medium';
        }

        // Stable trend
        if (accuracy > 85) return 'hard';
        if (accuracy > 70) return 'medium';
        if (accuracy > 50) return 'easy';
        return 'easy';
    }

    recommendNextCategory() {
        if (this.userHistory.length === 0) return 'hifz';

        const categoryPerformance = {};

        this.userHistory.forEach(result => {
            result.questions.forEach((q, idx) => {
                const category = q.category;
                if (!categoryPerformance[category]) {
                    categoryPerformance[category] = { correct: 0, total: 0 };
                }
                categoryPerformance[category].total++;
                if (result.responses[idx].selectedOptionIndex === q.correctOptionIndex) {
                    categoryPerformance[category].correct++;
                }
            });
        });

        let weakestCategory = 'hifz';
        let lowestAccuracy = 1;

        Object.entries(categoryPerformance).forEach(([category, stats]) => {
            const accuracy = stats.correct / stats.total;
            if (accuracy < lowestAccuracy) {
                lowestAccuracy = accuracy;
                weakestCategory = category;
            }
        });

        return weakestCategory;
    }

    estimateNextTestDuration() {
        if (this.userHistory.length === 0) return 600000; // 10 minutes default

        const recentTimes = this.userHistory.slice(-3).map(r => r.totalTimeMs);
        const avgTime = recentTimes.reduce((a, b) => a + b) / recentTimes.length;

        return Math.round(avgTime * 1.1); // 10% buffer
    }

    getMotivationalMessage(currentResult) {
        const trend = this.performanceTrend;
        const accuracy = parseFloat(currentResult.components.accuracy);
        const previousIQ = this.userHistory.length > 0 ? this.userHistory[this.userHistory.length - 1].iq : 100;
        const iqChange = currentResult.iq - previousIQ;

        if (accuracy >= 90 && iqChange > 0) {
            return 'exceptional_progress';
        }
        if (accuracy >= 80 && trend === 'improving') {
            return 'strong_improvement';
        }
        if (accuracy >= 70) {
            return 'good_effort';
        }
        if (accuracy >= 50 && iqChange >= -5) {
            return 'steady_progress';
        }
        return 'keep_trying';
    }
}

// ============================================================
// AUDIO MANAGER - Pure Logic Audio Control
// ============================================================

class AudioManager {
    constructor() {
        this.currentReciter = null;
        this.isPlaying = false;
        this.currentAudioUrl = null;
        this.audioElement = null;
        this.playbackListeners = [];
        this.reciters = {
            'afasi': { id: 'afasi', name: 'Al-Afasi', endpoint: 'https://cdn.example.com/recitation/afasi/{surah}.mp3' },
            'minshawi': { id: 'minshawi', name: 'Minshawi', endpoint: 'https://cdn.example.com/recitation/minshawi/{surah}.mp3' },
            'dosari': { id: 'dosari', name: 'Al-Dosari', endpoint: 'https://cdn.example.com/recitation/dosari/{surah}.mp3' },
            'ghamadi': { id: 'ghamadi', name: 'Ghamadi', endpoint: 'https://cdn.example.com/recitation/ghamadi/{surah}.mp3' },
            'ajami': { id: 'ajami', name: 'Ajami', endpoint: 'https://cdn.example.com/recitation/ajami/{surah}.mp3' },
            'hudhaifi': { id: 'hudhaifi', name: 'Hudhaifi', endpoint: 'https://cdn.example.com/recitation/hudhaifi/{surah}.mp3' },
        };
    }

    selectReciter(reciterId) {
        if (!this.reciters[reciterId]) {
            throw new Error(`Reciter ${reciterId} not found`);
        }
        this.stop();
        this.currentReciter = reciterId;
        this.notifyListeners('reciter:changed', { reciterId });
    }

    prepareAudio(surahId) {
        if (!this.currentReciter) {
            throw new Error('No reciter selected');
        }

        const reciter = this.reciters[this.currentReciter];
        const audioUrl = reciter.endpoint.replace('{surah}', surahId);

        this.currentAudioUrl = audioUrl;
        return {
            url: audioUrl,
            reciter: this.currentReciter,
            surahId: surahId,
        };
    }

    play(surahId) {
        if (this.isPlaying) {
            this.stop();
        }

        const audioConfig = this.prepareAudio(surahId);

        this.isPlaying = true;
        this.notifyListeners('audio:playing', audioConfig);

        return audioConfig;
    }

    stop() {
        if (!this.isPlaying) return;

        this.isPlaying = false;
        this.currentAudioUrl = null;
        this.notifyListeners('audio:stopped', {});
    }

    pause() {
        if (!this.isPlaying) return;

        this.isPlaying = false;
        this.notifyListeners('audio:paused', {});
    }

    resume() {
        if (this.isPlaying || !this.currentAudioUrl) return;

        this.isPlaying = true;
        this.notifyListeners('audio:resumed', { url: this.currentAudioUrl });
    }

    getAvailableReciters() {
        return Object.values(this.reciters).map(r => ({ id: r.id, name: r.name }));
    }

    getStatus() {
        return {
            isPlaying: this.isPlaying,
            currentReciter: this.currentReciter,
            currentAudioUrl: this.currentAudioUrl,
        };
    }

    onPlaybackEvent(callback) {
        this.playbackListeners.push(callback);
    }

    notifyListeners(eventType, data) {
        this.playbackListeners.forEach(cb => {
            try {
                cb({ type: eventType, data });
            } catch (error) {
                console.error(`Listener error: ${error.message}`);
            }
        });
    }
}

// ============================================================
// LANGUAGE MANAGER - Multilingual System
// ============================================================

class LanguageManager {
    static DEFAULT_LANGUAGE = 'uz';

    static translations = {
        uz: {
            'welcome': 'Xush kelibsiz!',
            'test.start': 'Testni boshlash',
            'test.finish': 'Testni tugatish',
            'test.reset': 'Testni qayta boshlash',
            'answer.submit': 'Javob berish',
            'answer.correct': 'To\'g\'ri javob!',
            'answer.incorrect': 'Xato javob',
            'result.title': 'Test Natijasi',
            'result.score': 'Natija',
            'result.iq': 'Qur\'onIQ Reyting',
            'result.level': 'Darajasi',
            'stat.total_tests': 'Jami testlar',
            'stat.total_questions': 'Jami savollar',
            'stat.correct_answers': 'To\'g\'ri javoblar',
            'stat.accuracy': 'To\'g\'rilik foizи',
            'stat.best_iq': 'Eng yuqori IQ',
            'motivation.exceptional': 'Ajoyib natija! Siz brilliant ko\'rsatdingiz!',
            'motivation.strong': 'Kuchli o\'sish! Davom ettiring!',
            'motivation.good': 'Yaxshi sa\'y! Yanada o\'rganing!',
            'motivation.steady': 'Barqaror iralamoq! Siz tez ortasiz!',
            'motivation.keep_trying': 'Yana urinib ko\'ring! Siz qolib yetasiz!',
            'error.no_test': 'Hech qanday test boshlangan emas',
            'error.reciter_not_found': 'Qori topilmadi',
            'error.language_not_supported': 'Tili qo\'llab-quvvatlanmaydi',
        },
        ru: {
            'welcome': 'Добро пожаловать!',
            'test.start': 'Начать тест',
            'test.finish': 'Завершить тест',
            'test.reset': 'Перезагрузить тест',
            'answer.submit': 'Отправить ответ',
            'answer.correct': 'Правильный ответ!',
            'answer.incorrect': 'Неправильный ответ',
            'result.title': 'Результат теста',
            'result.score': 'Результат',
            'result.iq': 'Рейтинг Куран IQ',
            'result.level': 'Уровень',
            'stat.total_tests': 'Всего тестов',
            'stat.total_questions': 'Всего вопросов',
            'stat.correct_answers': 'Правильные ответы',
            'stat.accuracy': 'Точность %',
            'stat.best_iq': 'Лучший IQ',
            'motivation.exceptional': 'Исключительный результат! Вы блестящи!',
            'motivation.strong': 'Сильный прогресс! Продолжайте!',
            'motivation.good': 'Хорошее усилие! Учитесь больше!',
            'motivation.steady': 'Стабильный прогресс! Вы быстро улучшаетесь!',
            'motivation.keep_trying': 'Попробуйте снова! Вы почти там!',
            'error.no_test': 'Тест не начинался',
            'error.reciter_not_found': 'Чтец не найден',
            'error.language_not_supported': 'Язык не поддерживается',
        },
        en: {
            'welcome': 'Welcome!',
            'test.start': 'Start Test',
            'test.finish': 'Finish Test',
            'test.reset': 'Reset Test',
            'answer.submit': 'Submit Answer',
            'answer.correct': 'Correct Answer!',
            'answer.incorrect': 'Incorrect Answer',
            'result.title': 'Test Result',
            'result.score': 'Score',
            'result.iq': 'Qur\'anIQ Rating',
            'result.level': 'Level',
            'stat.total_tests': 'Total Tests',
            'stat.total_questions': 'Total Questions',
            'stat.correct_answers': 'Correct Answers',
            'stat.accuracy': 'Accuracy %',
            'stat.best_iq': 'Best IQ',
            'motivation.exceptional': 'Exceptional result! You are brilliant!',
            'motivation.strong': 'Strong progress! Keep it up!',
            'motivation.good': 'Good effort! Learn more!',
            'motivation.steady': 'Steady progress! You are improving quickly!',
            'motivation.keep_trying': 'Try again! You are almost there!',
            'error.no_test': 'No test started',
            'error.reciter_not_found': 'Reciter not found',
            'error.language_not_supported': 'Language not supported',
        },
        ar: {
            'welcome': 'أهلا وسهلا!',
            'test.start': 'ابدأ الاختبار',
            'test.finish': 'أنهي الاختبار',
            'test.reset': 'أعد تشغيل الاختبار',
            'answer.submit': 'أرسل الإجابة',
            'answer.correct': 'إجابة صحيحة!',
            'answer.incorrect': 'إجابة خاطئة',
            'result.title': 'نتيجة الاختبار',
            'result.score': 'النتيجة',
            'result.iq': 'تقييم قرآن IQ',
            'result.level': 'المستوى',
            'stat.total_tests': 'إجمالي الاختبارات',
            'stat.total_questions': 'إجمالي الأسئلة',
            'stat.correct_answers': 'الإجابات الصحيحة',
            'stat.accuracy': 'دقة %',
            'stat.best_iq': 'أفضل معدل ذكاء',
            'motivation.exceptional': 'نتيجة استثنائية! أنت عبقري!',
            'motivation.strong': 'تقدم قوي! استمر!',
            'motivation.good': 'جهد جيد! تعلم أكثر!',
            'motivation.steady': 'تقدم مستقر! أنت تتحسن بسرعة!',
            'motivation.keep_trying': 'حاول مرة أخرى! أنت قريب جدا!',
            'error.no_test': 'لم يتم بدء اختبار',
            'error.reciter_not_found': 'لم يتم العثور على القارئ',
            'error.language_not_supported': 'اللغة غير مدعومة',
        },
    };

    static get(key, language = this.DEFAULT_LANGUAGE) {
        if (!this.translations[language]) {
            language = this.DEFAULT_LANGUAGE;
        }

        return this.translations[language][key] || this.translations[this.DEFAULT_LANGUAGE][key] || key;
    }

    static getSupportedLanguages() {
        return Object.keys(this.translations);
    }

    static validateLanguage(language) {
        return this.translations.hasOwnProperty(language);
    }

    static setDefaultLanguage(language) {
        if (this.validateLanguage(language)) {
            this.DEFAULT_LANGUAGE = language;
            return true;
        }
        return false;
    }

    static addTranslation(language, key, value) {
        if (!this.translations[language]) {
            this.translations[language] = {};
        }
        this.translations[language][key] = value;
    }
}

// ============================================================
// MOTIVATION ENGINE - Qur'anic Praise & Encouragement
// ============================================================

class MotivationEngine {
    static quranicWisdoms = [
        {
            text: 'Read the Quran with proper Tarteel (measured recitation).',
            source: 'Quran 73:4',
            category: 'tajwid',
            language: 'en',
        },
        {
            text: 'Reflect deeply on the Quran\'s meanings.',
            source: 'Quran 47:24',
            category: 'tafsir',
            language: 'en',
        },
        {
            text: 'Do not lose hope in Allah\'s mercy.',
            source: 'Quran 39:53',
            category: 'motivation',
            language: 'en',
        },
        {
            text: 'Verily, with hardship comes ease.',
            source: 'Quran 94:5',
            category: 'motivation',
            language: 'en',
        },
        {
            text: 'The best of you are those who learn the Quran and teach it.',
            source: 'Sahih Bukhari',
            category: 'hifz',
            language: 'en',
        },
    ];

    static getPraiseMessage(performanceLevel, iqScore) {
        const baseMessages = {
            exceptional: [
                'Mashaallah! Your brilliance shines through.',
                'SubhanAllah! You demonstrated exceptional understanding.',
                'Alhamdulillah! Your performance was outstanding.',
            ],
            strong: [
                'Well done! Your dedication is showing results.',
                'Great effort! Keep this momentum going.',
                'Excellent work! You are progressing beautifully.',
            ],
            good: [
                'Good job! You are making solid progress.',
                'Nice work! With continued effort, you will excel.',
                'Well attempted! Each attempt makes you stronger.',
            ],
            steady: [
                'You are on the right path. Keep going!',
                'Every step forward counts. Continue learning.',
                'Progress is not always linear. Stay persistent.',
            ],
            encouraging: [
                'Do not be discouraged. Every expert was once a beginner.',
                'Your effort is not in vain. Keep practicing.',
                'With patience and dedication, success will come.',
            ],
        };

        const messageArray = baseMessages[performanceLevel] || baseMessages.encouraging;
        return messageArray[Math.floor(Math.random() * messageArray.length)];
    }

    static getWisdomForCategory(category) {
        const categoryWisdoms = this.quranicWisdoms.filter(w => w.category === category);
        if (categoryWisdoms.length === 0) return this.quranicWisdoms[0];
        return categoryWisdoms[Math.floor(Math.random() * categoryWisdoms.length)];
    }

    static getMotivationalPackage(testResult, adaptiveEngine) {
        const performanceLevel = adaptiveEngine.getMotivationalMessage(testResult);

        return {
            praise: this.getPraiseMessage(performanceLevel, testResult.iq),
            wisdom: this.getWisdomForCategory(testResult.recommendedCategory || 'motivation'),
            nextStep: adaptiveEngine.recommendNextCategory(),
            nextDifficulty: adaptiveEngine.recommendNextDifficulty(),
            performanceLevel: performanceLevel,
        };
    }

    static validateWisdom(wisdom) {
        // Ensure wisdom comes from authenticated Quranic sources
        const authenticSources = [
            'Quran',
            'Sahih Bukhari',
            'Sahih Muslim',
            'Jami Tirmidhi',
            'Sunan Ibn Majah',
        ];

        const sourceMatch = wisdom.source.split(' ')[0];
        return authenticSources.includes(sourceMatch);
    }
}

// ============================================================
// RESULT ANALYZER - Comprehensive Performance Analysis
// ============================================================

class ResultAnalyzer {
    static analyzeStrengths(testResult) {
        const categoryPerformance = {};

        testResult.questions.forEach((question, idx) => {
            const category = question.category;
            const isCorrect = testResult.responses[idx].selectedOptionIndex === question.correctOptionIndex;

            if (!categoryPerformance[category]) {
                categoryPerformance[category] = { correct: 0, total: 0 };
            }

            categoryPerformance[category].total++;
            if (isCorrect) categoryPerformance[category].correct++;
        });

        const strengths = Object.entries(categoryPerformance)
            .filter(([_, stats]) => stats.correct / stats.total >= 0.75)
            .map(([category, stats]) => ({
                category,
                accuracy: ((stats.correct / stats.total) * 100).toFixed(1),
                questionCount: stats.total,
            }));

        return strengths;
    }

    static analyzeWeaknesses(testResult) {
        const categoryPerformance = {};

        testResult.questions.forEach((question, idx) => {
            const category = question.category;
            const isCorrect = testResult.responses[idx].selectedOptionIndex === question.correctOptionIndex;

            if (!categoryPerformance[category]) {
                categoryPerformance[category] = { correct: 0, total: 0 };
            }

            categoryPerformance[category].total++;
            if (isCorrect) categoryPerformance[category].correct++;
        });

        const weaknesses = Object.entries(categoryPerformance)
            .filter(([_, stats]) => stats.correct / stats.total < 0.75)
            .map(([category, stats]) => ({
                category,
                accuracy: ((stats.correct / stats.total) * 100).toFixed(1),
                questionCount: stats.total,
            }))
            .sort((a, b) => parseFloat(a.accuracy) - parseFloat(b.accuracy));

        return weaknesses;
    }

    static generateRecommendations(strengths, weaknesses) {
        const recommendations = [];

        if (weaknesses.length > 0) {
            const primaryWeakness = weaknesses[0];
            recommendations.push({
                priority: 'high',
                type: 'focus_area',
                category: primaryWeakness.category,
                suggestion: `Focus more on ${primaryWeakness.category}. Your accuracy here is ${primaryWeakness.accuracy}%.`,
                action: `increase_practice_${primaryWeakness.category}`,
            });
        }

        if (strengths.length > 0) {
            const strength = strengths[0];
            recommendations.push({
                priority: 'medium',
                type: 'leverage_strength',
                category: strength.category,
                suggestion: `You excel in ${strength.category}. Build on this success.`,
                action: 'maintain_excellence',
            });
        }

        if (weaknesses.length >= 2) {
            recommendations.push({
                priority: 'medium',
                type: 'targeted_study',
                suggestion: `Create a study plan targeting your weaker areas.`,
                action: 'create_study_plan',
            });
        }

        return recommendations;
    }

    static generateComprehensiveReport(testResult, userHistory) {
        const strengths = this.analyzeStrengths(testResult);
        const weaknesses = this.analyzeWeaknesses(testResult);
        const recommendations = this.generateRecommendations(strengths, weaknesses);

        return {
            testId: testResult.testId,
            timestamp: testResult.completedAt,
            iq: testResult.iq,
            level: testResult.level,
            accuracy: testResult.components.accuracy,
            strengths,
            weaknesses,
            recommendations,
            progress: userHistory.length > 0 ? {
                previousIQ: userHistory[userHistory.length - 1].iq,
                iqChange: testResult.iq - userHistory[userHistory.length - 1].iq,
                trend: this.calculateTrend(userHistory),
            } : null,
        };
    }

    static calculateTrend(userHistory) {
        if (userHistory.length < 2) return 'insufficient_data';

        const recent = userHistory.slice(-3).map(h => h.iq);
        let trend = 0;

        for (let i = 1; i < recent.length; i++) {
            trend += recent[i] - recent[i - 1];
        }

        const avgTrend = trend / (recent.length - 1);

        if (avgTrend > 3) return 'improving';
        if (avgTrend < -3) return 'declining';
        return 'stable';
    }
}

// ============================================================
// EXPORT (for module systems)
// ============================================================

if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        CoreController,
        TestEngine,
        IQScoringEngine,
        SmartAdaptiveEngine,
        AudioManager,
        LanguageManager,
        MotivationEngine,
        ResultAnalyzer,
    };
}
